# Gemini's Internal Process for Code Modification

This document outlines the step-by-step process I, Gemini, follow when I receive a request to change, update, or add a feature to a file in the codebase. This process is designed to be methodical, safe, and aligned with user intent.

### Step 1: Deconstruct the User's Request

First, I analyze the natural language of the prompt to understand the core intent.

-   **Goal Identification:** What is the ultimate objective? (e.g., "Fix a button," "Add a feature," "Update a text").
-   **Entity Extraction:** I identify key nouns and file paths mentioned. This includes file names, component names, function names, and specific UI text.
-   **Action Type:** I classify the request as a bug fix, feature addition, refactoring, or content update.

### Step 2: Information Gathering (Reading the Code)

This is a critical phase to ensure I am working with the most current version of the code.

1.  **Read Target File(s):** My immediate next step is to use the `read_file` tool on the most relevant file(s). This gives me the ground truth of the current codebase.
2.  **Analyze Context:** I analyze the file's structure:
    -   Component architecture (props, state, hooks).
    -   Event handlers (`onClick`, `onChange`, etc.).
    -   Data flow (what is passed down from parent components).
3.  **Cross-Reference (If Necessary):** If the change involves interactions between multiple components, I will read the related files to understand the complete data flow and component hierarchy.

### Step 3: Analysis and Planning

I synthesize the user's goal with the current state of the code to create a precise plan.

1.  **Pinpoint the Problem/Location:** I locate the exact lines of code that need to be changed.
2.  **Formulate the Solution:** I determine the *exact* change required, ensuring it is syntactically correct and logically sound within the context of the surrounding code.
3.  **Construct the Final File Content:** I generate the **entire content** of the file in my internal memory. This ensures that the final output is a complete, correct version of the file, rather than a patch that could have unforeseen consequences.

### Step 4: Execution and Confirmation

This is the final step where I apply the change and communicate the result.

1.  **Construct Tool Call:** I take the full file content from Step 3 and place it inside a `write_file` tool call.
2.  **Execute:** I execute the command to write the changes to the user's filesystem.
3.  **Confirm and Explain:** After the file is successfully written, I explicitly state what I have done and why. For example: "I have updated `src/components/Dashboard.tsx`. The `onClick` handler for the 'Update Profile' button now correctly navigates to `register_artist`, resolving the navigation bug."

---
*This document was generated by Gemini to provide transparency into its operational workflow.*
